# 本地优先记录存储策略实现计划

## 目标
将记录存储策略调整为"默认本地优先，仅在用户明确登录时同步到云端"，提升离线体验和隐私保护。

## 当前架构分析
- **现状**：混合架构（云端为主，本地为缓存）
- **数据流**：创建记录 → 调用API → 更新本地缓存
- **问题**：未登录时无法创建记录，网络依赖性强

## 新架构设计原则
1. **默认本地存储**：无论登录状态，记录始终先保存到本地数据库
2. **显式同步**：仅在用户登录后，主动触发同步操作
3. **冲突解决**：最后写入优先或合并策略
4. **离线优先**：所有功能在无网络状态下可用

## 技术实现方案

### 1. 本地数据库增强
- 扩展 `RecordModel` 增加同步状态字段：
  - `isSynced: bool` (是否已同步)
  - `userId: String?` (关联用户ID，本地记录时为null)
  - `localCreatedAt: DateTime` (本地创建时间)
- 修改 `LocalDbService` 支持按同步状态查询

### 2. 记录提供器重构
- 修改 `records_provider.dart` 逻辑：
  - 未登录状态：仅操作本地数据库
  - 登录状态：显示本地+云端合并视图
  - 同步操作：将本地未同步记录批量上传

### 3. 同步管理器
- 创建 `SyncManager` 类负责：
  - 检测登录状态变化
  - 批量上传未同步记录
  - 处理冲突合并
  - 进度通知

### 4. 用户界面调整
- 登录页面：增加"同步本地记录"选项
- 记录页面：显示同步状态图标
- 设置页面：添加手动同步按钮

## 实施步骤

### 阶段一：数据模型与本地存储
1. 更新 `RecordModel` 增加同步相关字段
2. 修改 `local_db_service.dart` 支持同步状态管理
3. 创建本地记录ID生成器（避免与云端ID冲突）

### 阶段二：记录提供器重构
1. 修改 `records_provider.dart` 支持双数据源
2. 实现本地优先的增删改查逻辑
3. 添加同步状态管理

### 阶段三：同步机制实现
1. 创建 `sync_manager.dart` 同步管理器
2. 实现批量上传接口
3. 添加冲突解决策略

### 阶段四：用户界面优化
1. 在登录流程中添加同步选项
2. 在记录列表显示同步状态
3. 添加设置页面的同步控制

### 阶段五：测试与优化
1. 离线场景测试
2. 同步冲突测试
3. 性能优化

## 关键决策点

### 冲突解决策略
- **方案A**：最后修改时间优先（简单可靠）
- **方案B**：内容合并（复杂但用户体验好）
- **建议**：先实现方案A，后续可升级到方案B

### 同步时机
- **登录时同步**：用户登录后自动同步
- **手动同步**：用户主动触发
- **后台同步**：定时或网络恢复时
- **建议**：登录时自动同步 + 手动同步按钮

### 存储限制
- 本地存储是否设置上限？
- 建议：初期不设限，后续根据用户反馈调整

## 风险评估
1. **数据丢失风险**：本地存储需确保可靠性
2. **同步冲突**：复杂场景需要健壮的冲突处理
3. **性能影响**：大数据量同步可能影响体验

## 迁移策略
- 现有用户数据保持云端存储
- 新版本首次启动时将云端数据下载到本地
- 渐进式迁移，确保数据安全

## 验收标准
- [ ] 未登录状态下可正常创建、查看记录
- [ ] 登录后本地记录能正确同步到云端
- [ ] 多设备间同步基本一致
- [ ] 网络中断不影响核心功能
- [ ] 同步进度可视化

## 后续优化方向
1. 增量同步优化
2. 端到端加密支持
3. 选择性同步（按标签、时间筛选）
4. 同步历史记录和回滚功能

---
*创建时间：2026-02-27*
*负责人：架构师模式*